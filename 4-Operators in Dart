1- Arithmetic Operation

~/, +,  -,  *,  /,  %,   -expr => ex.  -a = -2 (if a = 2)
Important:
~/  => convert the output to Integer

var c = 9 / 4    // output = 2.25
var c = 9 ~/ 4    // output = 2

Using unary minus


2- Type Test Operators
NOTE it doesn't test Valuse but compare with data type
is  ,  is !    // output is boolean
Ex.
var a = 2;
var b = "mohamed";

print (a is int)  // output = true or 1
print(b is !string) // output = false or 0
//print(a is 2)  // Error, can't compare with values only with data types

--------------------------------------------------------------------------------

"as" operator in Dart:
- it onverts(typecast) one type into another
- it checks the type at "runtime" and throws an error if the conversation is  invalid

why use "as" ?
sometimes u declare a variable with dynamic or Object, so dart is not sure what type of this variable
so you tell dart I'm sure about the type of this variable and make it (String) for example

Ex.
dynamic value = 20;
int number = value as int  // you created a new variable and set it to equal the "value" variable and defined it as integer
print(number)

--------------------------------------------------------------------------------

*BitWise Operators:
you can use them in Video Compression and Encryption or if you have memory limitation 
1- And "&"
5 & 7 = 5    // 
/*Solution
first converts the numbers into binaries
5 =  0 1 0 1
7 =  0 1 1 1 
AND => 1 and 1 = 1
       0 and 1 = 0
       0 and 0 = 0

OR => 1 or 0 = 1
      0 or 0 = 0
      1 or 1 = 1
1- Left Shift  
5 << 1 
5 =           0000 0101
then shift left (left ro right  "mean take from the left bit and add it to Right" )
it will be => 0000 1010

2- Shift Right (Note: this is different from Left Shift)
it like doesn't really shift, but move rigt with ignoring the right bit,
"but it keeps the sign"=> if the left-most bit was 0 it means the number is positive so after shifting we will keep the leftmost bit "zero"
and if the leftmost bit is "1" then it means the nmber is Negative, and after shifting we will keep the leftmost bit "1"
Summary=> Just move to the right with ignoring the rightmost bit and keep the leftmost bit as it
Ex.
6 >> 1;  //               6 = 0000 0110
after shift (or move right)=> 0000 0011

3- Unsigned Right Shift ">>>"
it's like Right Shift but always fill the leftmost bits with 0, "Ignore the sign", always Positive
Ex.
-5 >>> 1 = 2147483645
"مش فاهمها"


*/
ReaL Example of using Bitwise
in unix (in permission for example)
if (userPermission & READ_PERMISSION) == READ_PERMISSION:
  print("Can Read");
else:
print("Can't Read");

0000 0101
1111 1010
0000 0001
-----
1   1  1  1  1 0 1 1
128 64 32 16 8 4 2 1

